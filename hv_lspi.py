import gym
import numpy as np
import itertools
import sklearn.pipeline
import sklearn.preprocessing

def LSTDQ(data,k,phi,gamma,w_old,init):
	A = 0.001*np.identity(k)
	b = np.zeros((k,1))

	for s,a,r,sp in data:
		if init:
			ap = env.action_space.sample()
		else:
			ap = np.argmax([np.dot(phi(sp,0).transpose(),w_old),np.dot(phi(sp,1).transpose(),w_old)])
		A += np.dot(phi(s,a),(phi(s,a)-gamma*phi(sp,ap)).transpose())
		b += phi(s,a) * r

	w = np.dot(np.linalg.inv(A),b)
	return w

def LSPI(data,k,phi,gamma,epsilon):
	w = LSTDQ(D,k,phi,gamma,0,1)
	#while np.dot(w-w_old,w-w_old)>epsilon
	for i_iter in range(60):
		print("Iter :", i_iter)
		w = LSTDQ(D,k,phi,gamma,w,0)
	return w

# Doesn't work well
# State observation values itself does not help much
def phi0(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1], [x], [xv], [angle], [anglev]])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a == 0:
		phi = np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

# Works OK with 1000 transitions generated by a random policy
# 60 iterations
def phi1(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1],[x], [xv], [angle],[anglev],
					   [x**2], [xv**2], [angle**2], [anglev ** 2],
					   [angle * anglev]
					   ])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a ==0:
		phi=np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

# Doesn't work well
# Taylor exp up to 2nd order
# It seems increasing feature dim does not always help
def phi2(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1],[x], [xv], [angle],[anglev],
					   [x**2], [xv**2], [angle**2], [anglev ** 2],
					   [x*xv], [x*angle], [x*anglev],
					   [xv*angle], [xv*anglev],
					   [angle * anglev]
					   ])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a ==0:
		phi=np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

# ########################################3 작업중
# def rbf(x, c, s):
#     return np.exp(-1 * np.dot((x-c),(x-c)) / (2 * s**2) )
#
# def eval_rbf(rbf, rbf_mean_list,Mm_list):
#     y_pred = []
#     for i in range(len(rbf_mean_list)):
#         # a = np.array([rbf(s, c, s) for c, s, in zip(rbf_mean_list, Mm_list)])
# 		a = np.array([rbf(s, c, 4) for c, s, in zip(rbf_mean_list)])
#         # F = a.T.dot(self.w) + self.b
#         y_pred.append(a)
#     return np.array(y_pred)
#
#
# # RBF
# def phi3(s,a):
# 	x = s[0]
# 	xv = s[1]
# 	angle = s[2]
# 	anglev = s[3]
#
# 	# n_x=10
# 	# np.linspace(env.observation_space.low, env.observation_space.high, n_x)
#
# 	# 1000 transitions에 대해서 data_scale에서
# 	# mean x, xv, angle, anglev: [ 0.00894345  0.01835023  0.0031581  -0.01900848]
# 	# min:  [-0.21106106 -1.56648257 -0.20942541 -2.48049095]
# 	# max:  [ 0.21710167  1.5631182   0.20834027  2.56722881]
#
# 	min = np.array([-4.8, -1.8,  -0.418, -2.6])
# 	max = np.array([ 4.8,  1.8,   0.418,  2.6])
# 	n_discrete = [10,10,10,10]
# 	mean = []
#
# 	for i in range(np.size(max)):
# 		mean_tmp = np.linspace(min[i], max[i], n_discrete[i])
# 		mean.append(mean_tmp)
#
# 	rbf_mean_list=[]
# 	for (xi, xvi, anglei,anglevi) in itertools.product(mean[0], mean[1], mean[2], mean[3]):
# 		rbf_mean_list.append(np.array([xi, xvi, anglei, anglevi]))
# 	rbf_mean_arr = np.asarray(rbf_mean_list)
#
# 	rbf_val = eval_rbf(rbf, rbf_mean_list,Mm_list)
#
# 	phi_s = np.concatenate((np.array([[1]]),rbf_val), axis =0)
#
# 	# phi_s = np.array([[1],[x], [xv], [angle],[anglev],
# 	# 				   [x**2], [xv**2], [angle**2], [anglev ** 2],
# 	# 				   [x*xv], [x*angle], [x*anglev],
# 	# 				   [xv*angle], [xv*anglev],
# 	# 				   [angle * anglev]
# 	# 				   ])
#
# 	zero_vec = np.zeros_like(phi_s, dtype='float64')
#
# 	if a ==0:
# 		phi=np.concatenate((phi_s, zero_vec), axis=0)
# 	else:
# 		phi = np.concatenate((zero_vec, phi_s), axis=0)
#
# 	return phi


def data_scale(data):
	S = []
	for s, a, r, sp in data:
		S.append(s)
	S = np.array(S)
	max = np.amax(S,axis=0)
	min = np.amin(S,axis=0)
	mean = np.mean(S,axis=0)
	print("mean: ",mean)
	print("min: ",min)
	print("max: ", max)
	input()
	# std = np.std(S, axis=0)
	Mm = max-min
	S = (S-mean)/Mm *2
	for i in range(len(data)):
		data[i][0] = S[i]
	return data

################################################################
# Sample and save transitions using random policy
D = []
env = gym.make('CartPole-v0')
s = env.reset()

train_epi_cnt = 1
for i_step in range(5000):
	#env.render()
	print("Sampled steps: ", i_step)
	a = env.action_space.sample()
	sp, r, done, info = env.step(a)
	D.append([s,a,r,sp])
	s = sp
	if done:
		train_epi_cnt+=1
		s = env.reset()
		# if(np.random.rand()>0.5):
		# 	s[0] = 2.2
		# else:
		# 	s[0] = -2.2
print("Train episodes: ", train_epi_cnt)
################################################################

D = data_scale(D)

# Run LSPI algo. to learn the w
# k=10/20 since 5/10 dim for each of action 0 and 1
# w = LSPI(D,10,phi0,0.9,1)
w = LSPI(D,20,phi1,0.9,1)

############################################################################
#Testing the learned policy(learned w) and gathering transitions.
############################################################################
n_test_epi = 100
# def test(w, phi1)
render_image = True


store_trans = False

print("testing")
ret_list = []
for i_epi in range(n_test_epi):
	s = env.reset()
	ret = 0
	done = False
	while not done:
		# a = np.argmax([np.dot(phi0(s, 0).transpose(), w), np.dot(phi0(s, 1).transpose(), w)])
		a = np.argmax([np.dot(phi1(s, 0).transpose(), w), np.dot(phi1(s, 1).transpose(), w)])
		if render_image is True:
			env.render()
		sp, r, done, info = env.step(a)
		ret += r
		if store_trans:
			D.append([s, a, r, sp])
		s = sp
	ret_list.append(ret)
	print("Episode: {} \n Return: {}".format(i_epi, ret))
ret_arr = np.asarray(ret_list)
avg_ret = np.mean(ret_arr)
print("Avg_return :", avg_ret)
############################################################################

# if __name__ == '__main__':
#
#     feature_op = ['gaussian', 'polynomial']
#     feature_func = feature_op[1]
#     feature_dim = [5, 10, 20]
#     feature_dim = feature_dim[1]
#     _main(game_title="CartPole", num_episode=100, basis_opt=basis_opt, basis_function_dim=bf_dim)