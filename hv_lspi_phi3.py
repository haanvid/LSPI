import gym
import numpy as np
import itertools
import sklearn.pipeline
import sklearn.preprocessing

def LSTDQ(data,k,phi,gamma,w_old,init):
	A = 0.001*np.identity(k)
	b = np.zeros((k,1))
	i=0
	for s,a,r,sp in data:
		i+=1
		# print("transition: ",i)
		if init:
			ap = env.action_space.sample()
		else:
			ap = np.argmax([np.dot(phi(sp,0).transpose(),w_old),np.dot(phi(sp,1).transpose(),w_old)])
		# print("LSTDQ1111")
		phi_s_a =phi(s,a)
		A += np.dot(phi_s_a,(phi_s_a-gamma*phi(sp,ap)).transpose())
		# print("LSTDQ2222")
		b += phi_s_a * r

	w = np.dot(np.linalg.inv(A),b)
	return w

def LSPI(data,k,phi,gamma,epsilon):
	w = LSTDQ(D,k,phi,gamma,0,1)
	#while np.dot(w-w_old,w-w_old)>epsilon
	for i_iter in range(60):
		print("Iter :", i_iter)
		w = LSTDQ(D,k,phi,gamma,w,0)
	return w

# Doesn't work well
# State observation values itself does not help much
def phi0(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1], [x], [xv], [angle], [anglev]])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a == 0:
		phi = np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

# Works OK with 1000 transitions generated by a random policy
# 60 iterations
def phi1(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1],[x], [xv], [angle],[anglev],
					   [x**2], [xv**2], [angle**2], [anglev ** 2],
					   [angle * anglev]
					   ])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a ==0:
		phi=np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

# Doesn't work well
# Taylor exp up to 2nd order
# It seems increasing feature dim does not always help
def phi2(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	phi_s = np.array([[1],[x], [xv], [angle],[anglev],
					   [x**2], [xv**2], [angle**2], [anglev ** 2],
					   [x*xv], [x*angle], [x*anglev],
					   [xv*angle], [xv*anglev],
					   [angle * anglev]
					   ])
	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a ==0:
		phi=np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi

########################################3 작업중
def rbf(x, c, s):
	# print((x-c)[0].shape)
	# print(np.dot((x-c)[0],(x-c)[0]))
	# input("dot prod")
	tmp = (x-c)[0]
	return np.exp(-1  / (2 * s**2) * np.dot(tmp,tmp))
	# return np.exp(-1  / (2 * s**2) )

def eval_rbf(s, rbf_mean_list):
	y_pred = []
	# print(len(rbf_mean_list))
	# print(rbf_mean_list)
	# input("len")
	# for i in range(len(rbf_mean_list)):
		# a = np.array([rbf(s, c, s) for c, s, in zip(rbf_mean_list, Mm_list)])
	a = np.array([rbf(s, c, 6) for c in zip(rbf_mean_list)])
	# print(a)
	# input("a")
        # F = a.T.dot(self.w) + self.b
	# y_pred.append(a)
	return a #np.array(y_pred)


# RBF
def phi3(s,a):
	x = s[0]
	xv = s[1]
	angle = s[2]
	anglev = s[3]

	# n_x=10
	# np.linspace(env.observation_space.low, env.observation_space.high, n_x)

	# 1000 transitions에 대해서 data_scale에서
	# mean x, xv, angle, anglev: [ 0.00894345  0.01835023  0.0031581  -0.01900848]
	# min:  [-0.21106106 -1.56648257 -0.20942541 -2.48049095]
	# max:  [ 0.21710167  1.5631182   0.20834027  2.56722881]

	# min = np.array([-4.8, -1.8,  -0.418, -2.6])
	# max = np.array([ 4.8,  1.8,   0.418,  2.6])

	min = np.array([-2.8, -1.8, -0.218, -2.6])
	max = np.array([2.8, 1.8, 0.218, 2.6])
	n_discrete = [2,2,2,2]
	mean = []
	# print("1111111111111111")
	for i in range(np.size(max)):
		mean_tmp = np.linspace(min[i], max[i], n_discrete[i])
		mean.append(mean_tmp)
	# print("222222222222222")
	rbf_mean_list=[]
	for (xi, xvi, anglei,anglevi) in itertools.product(mean[0], mean[1], mean[2], mean[3]):
		rbf_mean_list.append(np.array([xi, xvi, anglei, anglevi]))
	rbf_mean_arr = np.asarray(rbf_mean_list)
	# print("333333333333333")
	rbf_val = eval_rbf(s, rbf_mean_list)

	# print(rbf_val.shape)
	# input("rbf_val shape")
	# print("4444444444444444")
	phi_s = np.concatenate((np.array([[1]]),rbf_val.reshape(-1,1)), axis =0)

	# phi_s = np.array([[1],[x], [xv], [angle],[anglev],
	# 				   [x**2], [xv**2], [angle**2], [anglev ** 2],
	# 				   [x*xv], [x*angle], [x*anglev],
	# 				   [xv*angle], [xv*anglev],
	# 				   [angle * anglev]
	# 				   ])

	zero_vec = np.zeros_like(phi_s, dtype='float64')

	if a ==0:
		phi=np.concatenate((phi_s, zero_vec), axis=0)
	else:
		phi = np.concatenate((zero_vec, phi_s), axis=0)

	return phi


def data_scale(data):
	S = []
	for s, a, r, sp in data:
		S.append(s)
	S = np.array(S)
	max = np.amax(S,axis=0)
	min = np.amin(S,axis=0)
	mean = np.mean(S,axis=0)
	# print("mean: ",mean)
	# print("min: ",min)
	# print("max: ", max)
	# input()
	# std = np.std(S, axis=0)
	Mm = max-min
	S = (S-mean)/Mm *2
	for i in range(len(data)):
		data[i][0] = S[i]
	return data

################################################################
# Sample and save transitions using random policy
D = []
env = gym.make('CartPole-v0')
s = env.reset()

train_epi_cnt = 1
for i_step in range(2000):
	#env.render()
	print("Sampled steps: ", i_step)
	a = env.action_space.sample()
	sp, r, done, info = env.step(a)
	D.append([s,a,r,sp])
	s = sp
	if done:
		train_epi_cnt+=1
		s = env.reset()
		# if(np.random.rand()>0.5):
		# 	s[0] = 2.2
		# else:
		# 	s[0] = -2.2
print("Train episodes: ", train_epi_cnt)
################################################################

# D = data_scale(D)

# Run LSPI algo. to learn the w
# k=10/20 since 5/10 dim for each of action 0 and 1
# w = LSPI(D,10,phi0,0.9,1)
print("Run LSPI algorithm")
w = LSPI(D,34,phi3,0.9,1)

############################################################################
#Testing the learned policy(learned w) and gathering transitions.
############################################################################
n_test_epi = 100
# def test(w, phi1)
render_image = True
store_trans = False

print("Testing")
ret_list = []
for i_epi in range(n_test_epi):
	s = env.reset()
	ret = 0
	done = False
	while not done:
		# a = np.argmax([np.dot(phi0(s, 0).transpose(), w), np.dot(phi0(s, 1).transpose(), w)])
		a = np.argmax([np.dot(phi3(s, 0).transpose(), w), np.dot(phi3(s, 1).transpose(), w)])
		if render_image is True:
			env.render()
		sp, r, done, info = env.step(a)
		ret += r
		if store_trans:
			D.append([s, a, r, sp])
		s = sp
	ret_list.append(ret)
	print("Episode: {} \n Return: {}".format(i_epi, ret))
ret_arr = np.asarray(ret_list)
avg_ret = np.mean(ret_arr)
print("Avg_return :", avg_ret)
############################################################################

# if __name__ == '__main__':
#
#     feature_op = ['gaussian', 'polynomial']
#     feature_func = feature_op[1]
#     feature_dim = [5, 10, 20]
#     feature_dim = feature_dim[1]
#     _main(game_title="CartPole", num_episode=100, basis_opt=basis_opt, basis_function_dim=bf_dim)